## stdin / stdout


```sh
cat
```
- Die shell wartet was du eingibst. Mit *Strg + C* kannst du es dann beenden.


```sh
cat > test.txt
```

- Der Befehl zeigt dass du eine Datei macht und darin auch was reinschreiben kann.

```sh
cat < text.txt
```
- Der Befehl zeigt den text der in *test.txt* steht.

```sh
cat Hallo Welt > hallo.txt
```
- Mit cat Hallo Welt > kannst du den text von *hallo.txt* überschreiben.

```sh
cat Hallo welt >> hallo.txt
```
- Mit cat Hallo Welt >> kanst den text unten einfügen ohne was zu löschen.

### quotes

```sh
mkdir Urlaubs Fotos

mkdir 'Urlaubs fotos'
```
- Bei dem esten mkdir werden Urlaub und fotos zwei verschieden Ordner

- Bei dem zweiten mkdir werden Urlaubs fotos ein ganzer Ordner wegen den  ' '


```sh
echo >>> Achtung <<<

bash: syntax error near unexpected token `>'

echo '>>> Achtung <<<'
```

- Bei dem ersten echo wird es einen error geben da es keine ' ' gibt.

- Bei dem zweiten echo passt alles.


## Übung 1

Übung (Kopie mit cat)

Erstelle mit Hilfe von “cat” eine Kopie der Datei test.txt in der neuen Datei test2.txt. test2.txt soll den gleichen Inhalt enthalten wie test.txt. Prüfe ob test2.txt wirklich den gewünschten Inhalt hat.

```sh
cat > text.txt
Hallo Welt
tschüss welt

"strg + C"

cat test.txt > test2.txt
cat< test2.txt

```

## Übung 2

übung (dirlist in File)
Schreibe den, mittels ls ermittelten, Inhalt des Verzeichnisses /etc in eine Textdatei mit dem Namen etcdir.txt. Inhalt des Verzeichnisses = die Namen der enthaltenen Files und Unterverzeichnisse.

```sh
ls /etc etcdir.txt

cat etcdir.txt


alternatives
apt
bash.bashrc
bash_completion.d
bindresvport.blacklist
ca-certificates
ca-certificates.conf
cloud
cron.d
cron.daily
debconf.conf
debian_version
default
dpkg
e2scrub.conf
environment
fonts
fstab
gai.conf
gitconfig
gnutls
group
group-
gshadow
gshadow-
gss
host.conf
hostname
hosts
init.d
issue
issue.net
kernel
ld.so.cache
ld.so.conf
ld.so.conf.d
legal
libaudit.conf
locale.alias
locale.conf
locale.gen
localtime
login.defs
logrotate.d
lsb-release
machine-id
mke2fs.conf
mtab
networks
nix
nixmodules
nsswitch.conf
opt
os-release
pam.conf
pam.d
passwd
passwd-
perl
profile
profile.d
rc0.d
rc1.d
rc2.d
rc3.d
rc4.d
rc5.d
rc6.d
rcS.d
replit
resolv.conf
rmt
security
selinux
shadow
shadow-
shells
skel
ssl
subgid
subgid-
subuid
subuid-
sysctl.conf
sysctl.d
systemd
terminfo
update-motd.d
xattr.conf
zoneinfo
```

## Übung 3

Übung (os-release)
Es gibt eine Datei /etc/os-release.

Betrachte deren Inhalt mit cat, welche Informationen kannst du daraus ableiten. Würde diese Information einem Hacker helfen der sich Zugriff auf das System verschafft hat? Wenn ja, wie?
Wie wird die Datei mit ls -l angezeigt? Was bedeutet diese Anzeige?

```sh
cat </etc/os-realse

PRETTY_NAME="Ubuntu 24.04.2 LTS"
NAME="Ubuntu"
VERSION_ID="24.04"
VERSION="24.04.2 LTS (Noble Numbat)"
VERSION_CODENAME=noble
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=noble
LOGO=ubuntu-logo


* Würde es dem Hacker helfen? *

ja würde es.

* Wie es helfen kann : *

Der hacker sieht welches Betriebssystem und Welche Version läuft damit kann er nach Sicherheitlücken suchen und passende Tools. Aber die Datei allein reicht nicht aus um das System zu hacken.



ls -l /etc/os-release

 
lrwxrwxrwx 1 root root 21 Feb  5  2025 /etc/os-release -> ../usr/lib/os-release

Das l bedeutet dass es ei symbolischer Link ist, keine echte Datei.

* rwxrwxrwx *

Das zeigt uns dass alle Besitzer, Gruppen etc. alles mit dem Link mach können.

 * root root *

Besitzer und Gruppe sind root.

* ../usr/lib/os-release *

Das ist die echte Datei.
```

## Übung 4

Übung (Textdatei erstellen)
Mit Hilfe von mehreren echo Befehlen können einfache Textdateien erstellt werden.

Erzeuge nur unter Verwendung von echo Befehlen die Datei made_by_echoing.txt mit Inhalt:

=====================
=    HTL BRAUNAU    =
=====================
= 2AHITS Gruppe n   =
= x Schülerinnen    =
= y Schüler         =
=====================
Setze für n, x und y die richtigen Werte ein.

```sh

echo "=====================" > made_by_echoing.txt

echo "=    HTL BRAUNAU     = " >> made_by_echoing.txt

echo "=====================" >> made_by_echoing.txt

echo "=  2AHITS Gruppe 2   = " >> made_by_echoing.txt

echo "=  x Schülerinnen    = " >> made_by_echoing.txt

echo "=  y Schüler      = " >> made_by_echoing.txt

echo "===================" >> made_by_echoing.txt


 * Ausgabe * 

        =====================
        =    HTL BRAUNAU    =
        =====================
        =  2AHITS Gruppe 2  =
        =  0 Schülerinnen   =
        =  26 Schüler       =
        =====================
```



## Übung (C in/out)

Auch selbstgeschriebene C Programme lesen von stdin und schreiben auf stdout. Und daher kann man auch hier die Dateiumleitung mit <, >, oder >> verwenden. Das Programm merkt davon gar nichts.
 
Erstelle eine Datei sum.cpp und öffne diese im Replit Editor.
 
Schreibe ein C Programm das zuerst eine Anzahl (int n) einliest.
 
Dann werden n weitere ganze Zahlen eingelesen und die Summe dieser Zahlen ermittelt.
 
Am Ende gibt das Programm die Summe aus (dies soll die einzige Ausgabe des Programms sein).
Beispiel-Programmablauf (n=3):
```
3
5
4
2
11
```
Bedeutung: Es sollen 3 Zahlen eingegeben werden, diese sind 5, 4 und 2. Deren Summe ist die Ausgabe 11.
 
Compiliere das Programm mit folgender Kommandozeile:
g++ -o sum sum.cpp
Wenn keine Compile-Fehler auftreten wird im gleichen Verzeichnis das Programm mit dem Namen sum erzeugt. Prüfe mit ls ob vorhanden.
 
Behebe evtl. Compiler-Fehler und starte dann das Programm mit:
./sum
Erstelle eine Textdatei mit den Input Daten für das Programm sum. Z.B.
```
5
1
2
3
4
5
```
Rufe nun das Programm auf und leite die Textdatei per Dateiumleitung ins stdin des Programms sum um. Schreibe weiters den Output des Programms in eine Textdatei.
 
## sum.cpp:
 
```cpp
#include <stdio.h>
 
int main()
{
  
        int n = 0;
  int zahl = 0;
  int sum = 0;
 
 printf(" Anzahl der Zahlen : \n");
  
        scanf("%d", &n);
 
  
for (int i = 0; i <= n; i++)
    {
     printf("zahl: ");
     scanf("%d", &zahl);
 
      sum += zahl;
    }
 
  printf("Die Summe der Zahlen: %d", sum);
 
  return 0;
}
```



## Übung 7

Übung (C Hallo Welt)
Erstelle nur mit Hilfe von echo Befehlen eine Datei hello.cpp mit folgendem Inhalt:

#include <iostream>

int main() {
  printf("\n\t*** Hallo Welt ***\n");
  return 0;
}
Hinweis: Verwende einfache Hochkommas rund um den mit echo auszugebenden Text (Beispiel: echo 'text') ansonsten hat die shell Schwierigkeiten mit den Sonderzeichen #,<,> etc.

Compiliere und starte das C Programm aus der Kommandozeile.

```sh
echo '#include <iostream>' > hello.cpp

echo '' >> hello.cpp

echo 'int main() { ' >> hello.cpp

echo '   printf("\n\t*** Hallo Welt ***\n"); ' >> hello.cpp

echo '   return 0; ' >> hello.cpp

echo ' } ' >> hello.cpp


```

## Übung 8

Übung (semikolon in command-line)
Mit Strich-Punkt (;) getrennt lassen sich auch 2 Befehle hintereinander in der Kommandozeile schreiben – diese werden dann nacheinander ausgeführt.

Probiere aus:

Mit echo einen Text in eine Datei schreiben und deren Inhalt gleich wieder ausgeben
Ein C-Programm compilieren und sofort danach starten

```sh
Bsp 1) 

echo 'Hallo Welt!' > text.txt; cat text.txt

Ergebniss: 

Hallo Welt!


Bsp 2) 

g++ -o hello hello.cpp; ./hello



```

## Übung 9

Übung (Here-Documents)
Informiere dich über die Here-Documents Schreibweise (=Syntax) und führe damit die Aufgabenstellungen “Textdatei erstellen” und “C Hallo Welt” noch einmal aus.

```sh

cat <<EOF > made_by_echoing.txt

        =====================
        =    HTL BRAUNAU    =
        =====================
        =  2AHITS Gruppe 2  =
        =  0 Schülerinnen   =
        =  26 Schüler       =
        =====================


cat <<EOF > hello.cpp

include <iostream>
int main() {
 printf("\n\t*** Hallo Welt ***\n");
 return 0;
}


```







